<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory EvenOdd (Isabelle2015: May 2015)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory EvenOdd</h1>

<span class="command">theory</span> <span class="name">EvenOdd</span><br/>
<span class="keyword">imports</span> <a href="IsaLibs.html"><span class="name">IsaLibs</span></a><br/>

</div>
<div class="source">
<pre><span class="keyword1">theory</span> EvenOdd
<span class="keyword2">imports</span> <span class="string">&quot;IsaLibs/IsaLibs&quot;</span>
<span class="keyword2">begin</span>

<span class="keyword1">section</span> <span class="verbatim">{* Even/Odd *}</span>

<span class="keyword1">text</span> <span class="verbatim">{* This theory file shows how to find the functions Even/Odd using
 mutual recursion in Isabelle/HOL. *}</span>

<span class="keyword1">subsection</span> <span class="verbatim">{* Destructor style functional scheme *}</span>

<span class="keyword1">text</span> <span class="verbatim">{* We first define the functional space of a destructor style functional scheme. *}</span>

<span class="keyword1">definition</span> scheme_dest <span class="keyword2">where</span>
<span class="string">&quot;scheme_dest M N &equiv; &exist;(f::nat=&gt;bool) (g::nat=&gt;bool). &forall;(x::nat).
  ((f x = M x (0::nat) True False (&lambda;x. x - (1::nat)) (&lambda;x y z. if x then (y::bool) else z) (op = :: nat=&gt;nat=&gt;bool) g) &and;
   (g x = N x (0::nat) True False (&lambda;x. x - (1::nat)) (&lambda;x y z. if x then (y::bool) else z) (op = :: nat=&gt;nat=&gt;bool) f))&quot;</span>

<span class="keyword1">text</span> <span class="verbatim">{* Now we get the terminating closure of the destructor style functional scheme. *}</span>

<span class="keyword1">definition</span> terminating_closure_scheme_dest <span class="keyword2">where</span>
<span class="string">&quot;terminating_closure_scheme_dest M N &equiv; &exist;f g. &forall;(x::nat) c<span class="hidden">&#8681;</span><sub>f</sub> c<span class="hidden">&#8681;</span><sub>g</sub> (v<span class="hidden">&#8681;</span><sub>f</sub>::bool) (v<span class="hidden">&#8681;</span><sub>g</sub>::bool).
  ((f M N 0 c<span class="hidden">&#8681;</span><sub>g</sub> v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> x = v<span class="hidden">&#8681;</span><sub>f</sub>) &and;
   (f M N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) c<span class="hidden">&#8681;</span><sub>g</sub> v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> x = M x (0::nat)
                                 True False
                                 (&lambda;x. x - (1::nat))
                                 (&lambda;x y z. if x then (y::bool) else z)
                                 (op = :: nat=&gt;nat=&gt;bool)
                                 (g M N c<span class="hidden">&#8681;</span><sub>f</sub> c<span class="hidden">&#8681;</span><sub>g</sub> v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub>)) &and;
   (g M N c<span class="hidden">&#8681;</span><sub>f</sub> 0 v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> x = v<span class="hidden">&#8681;</span><sub>g</sub>) &and;
   (g M N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) (Suc c<span class="hidden">&#8681;</span><sub>g</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> x = N x (0::nat)
                                       True False
                                       (&lambda;x. x - (1::nat))
                                       (&lambda;x y z. if x then (y::bool) else z)
                                       (op = :: nat=&gt;nat=&gt;bool)
                                       (f M N c<span class="hidden">&#8681;</span><sub>f</sub> (Suc c<span class="hidden">&#8681;</span><sub>g</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub>)))&quot;</span>

<span class="keyword1">text</span> <span class="verbatim">{* All individuals generated by @{term &quot;terminating_closure_scheme_dest&quot;}
  are terminating, regardless the value of @{term &quot;M&quot;} and @{term &quot;N&quot;}. The proof will need
  the witnesses @{term &quot;f<span class="hidden">&#8681;</span><sub>d</sub>&quot;} and @{term &quot;g<span class="hidden">&#8681;</span><sub>d</sub>&quot;} which we define below. *}</span>

<span class="keyword1">fun</span> f<span class="hidden">&#8681;</span><sub>d</sub> <span class="keyword2">and</span> g<span class="hidden">&#8681;</span><sub>d</sub> <span class="keyword2">where</span>
<span class="string">&quot;f<span class="hidden">&#8681;</span><sub>d</sub> M N 0 c<span class="hidden">&#8681;</span><sub>g</sub> v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> (x::nat) = (v<span class="hidden">&#8681;</span><sub>f</sub>::bool)&quot;</span><span class="delimiter">|</span>
<span class="string">&quot;f<span class="hidden">&#8681;</span><sub>d</sub> M N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) c<span class="hidden">&#8681;</span><sub>g</sub> v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> x = M x (0::nat)
                                 True False
                                 (&lambda;x. x - (1::nat))
                                 (&lambda;x y z. if x then (y::bool) else z)
                                 (op = :: nat=&gt;nat=&gt;bool)
                                 (g<span class="hidden">&#8681;</span><sub>d</sub> M N c<span class="hidden">&#8681;</span><sub>f</sub> c<span class="hidden">&#8681;</span><sub>g</sub> v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub>)&quot;</span><span class="delimiter">|</span>
<span class="string">&quot;g<span class="hidden">&#8681;</span><sub>d</sub> M N c<span class="hidden">&#8681;</span><sub>f</sub> 0 v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> x = (v<span class="hidden">&#8681;</span><sub>g</sub>::bool)&quot;</span><span class="delimiter">|</span>
<span class="string">&quot;g<span class="hidden">&#8681;</span><sub>d</sub> M N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) (Suc c<span class="hidden">&#8681;</span><sub>g</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> (x::nat) = N x (0::nat)
                                       True False
                                       (&lambda;x. x - (1::nat))
                                       (&lambda;x y z. if x then (y::bool) else z)
                                       (op = :: nat=&gt;nat=&gt;bool)
                                       (f<span class="hidden">&#8681;</span><sub>d</sub> M N c<span class="hidden">&#8681;</span><sub>f</sub> (Suc c<span class="hidden">&#8681;</span><sub>g</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub>)&quot;</span>

<span class="keyword1">text</span> <span class="verbatim">{* Proof. *}</span>

<span class="keyword1">theorem</span> <span class="string">&quot;terminating_closure_scheme_dest M N&quot;</span>
<span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>unfold terminating_closure_scheme_dest_def<span class="delimiter">)</span>
<span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule_tac x<span class="delimiter">=</span><span class="string">&quot;f<span class="hidden">&#8681;</span><sub>d</sub>&quot;</span> <span class="keyword2">in</span> exI<span class="delimiter">)</span>
<span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule_tac x<span class="delimiter">=</span><span class="string">&quot;g<span class="hidden">&#8681;</span><sub>d</sub>&quot;</span> <span class="keyword2">in</span> exI<span class="delimiter">)</span>
<span class="keyword1">by</span> simp

<span class="keyword1">subsection</span> <span class="verbatim">{* Constructor style functional scheme *}</span>

<span class="keyword1">text</span> <span class="verbatim">{* Now we define the functional space of a constructor style functional scheme. *}</span>

<span class="keyword1">definition</span> scheme_const <span class="keyword2">where</span>
<span class="string">&quot;scheme_const M N &equiv; &exist;(f::nat=&gt;bool) (g::nat=&gt;bool). &forall;(x::nat).
  ((f 0 = True) &and;
   (f (Suc x) = M x Suc (0::nat) g) &and;
   (g 0 = False) &and;
   (g (Suc x) = N x Suc (0::nat) f))&quot;</span>

<span class="keyword1">text</span> <span class="verbatim">{* Now we get the terminating closure of the constructor style functional scheme. *}</span>

<span class="keyword1">definition</span> terminating_closure_scheme_const <span class="keyword2">where</span>
<span class="string">&quot;terminating_closure_scheme_const M N &equiv; &exist;f g. &forall;(x::nat) c<span class="hidden">&#8681;</span><sub>f</sub> c<span class="hidden">&#8681;</span><sub>g</sub> v<span class="hidden">&#8681;</span><sub>f</sub> (v<span class="hidden">&#8681;</span><sub>g</sub>::bool).
  ((f M N 0 c<span class="hidden">&#8681;</span><sub>g</sub> v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> x = v<span class="hidden">&#8681;</span><sub>f</sub>) &and;
   (f M N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) c<span class="hidden">&#8681;</span><sub>g</sub> v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> 0 = True) &and;
   (f M N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) c<span class="hidden">&#8681;</span><sub>g</sub> v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> (Suc x) = M x Suc (0::nat)
                                 (g M N c<span class="hidden">&#8681;</span><sub>f</sub> c<span class="hidden">&#8681;</span><sub>g</sub> v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub>)) &and;
   (g M N c<span class="hidden">&#8681;</span><sub>f</sub> 0 v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> x = v<span class="hidden">&#8681;</span><sub>g</sub>) &and;
   (g M N c<span class="hidden">&#8681;</span><sub>f</sub> (Suc c<span class="hidden">&#8681;</span><sub>g</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> 0 = False) &and;
   (g M N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) (Suc c<span class="hidden">&#8681;</span><sub>g</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> (Suc x) = N x Suc (0::nat) 
                                             (f M N c<span class="hidden">&#8681;</span><sub>f</sub> (Suc c<span class="hidden">&#8681;</span><sub>g</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub>)))&quot;</span>

<span class="keyword1">text</span> <span class="verbatim">{* All individuals generated by @{term &quot;terminating_closure_scheme_const&quot;}
  are terminating, regardless the value of @{term &quot;M&quot;} and @{term &quot;N&quot;}. The proof will need
  the witnesses @{term &quot;f<span class="hidden">&#8681;</span><sub>c</sub>&quot;} and @{term &quot;g<span class="hidden">&#8681;</span><sub>c</sub>&quot;} which we define below. *}</span>

<span class="keyword1">fun</span> f<span class="hidden">&#8681;</span><sub>c</sub> <span class="keyword2">and</span> g<span class="hidden">&#8681;</span><sub>c</sub> <span class="keyword2">where</span>
<span class="string">&quot;f<span class="hidden">&#8681;</span><sub>c</sub> M N 0 c<span class="hidden">&#8681;</span><sub>g</sub> v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> (x::nat) = (v<span class="hidden">&#8681;</span><sub>f</sub>::bool)&quot;</span><span class="delimiter">|</span>
<span class="string">&quot;f<span class="hidden">&#8681;</span><sub>c</sub> M N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) c<span class="hidden">&#8681;</span><sub>g</sub> v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> 0 = True&quot;</span><span class="delimiter">|</span>
<span class="string">&quot;f<span class="hidden">&#8681;</span><sub>c</sub> M N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) c<span class="hidden">&#8681;</span><sub>g</sub> v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> (Suc x) = M x Suc (0::nat)
                                 (g<span class="hidden">&#8681;</span><sub>c</sub> M N c<span class="hidden">&#8681;</span><sub>f</sub> c<span class="hidden">&#8681;</span><sub>g</sub> v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub>)&quot;</span><span class="delimiter">|</span>
<span class="string">&quot;g<span class="hidden">&#8681;</span><sub>c</sub> M N c<span class="hidden">&#8681;</span><sub>f</sub> 0 v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> x = (v<span class="hidden">&#8681;</span><sub>g</sub>::bool)&quot;</span><span class="delimiter">|</span>
<span class="string">&quot;g<span class="hidden">&#8681;</span><sub>c</sub> M N c<span class="hidden">&#8681;</span><sub>f</sub> (Suc c<span class="hidden">&#8681;</span><sub>g</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> 0 = False&quot;</span><span class="delimiter">|</span>
<span class="string">&quot;g<span class="hidden">&#8681;</span><sub>c</sub> M N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) (Suc c<span class="hidden">&#8681;</span><sub>g</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub> (Suc x) = N x Suc (0::nat)
                                             (f<span class="hidden">&#8681;</span><sub>c</sub> M N c<span class="hidden">&#8681;</span><sub>f</sub> (Suc c<span class="hidden">&#8681;</span><sub>g</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>g</sub>)&quot;</span>

<span class="keyword1">text</span> <span class="verbatim">{* Proof. *}</span>

<span class="keyword1">theorem</span> <span class="string">&quot;terminating_closure_scheme_const M N&quot;</span>
<span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>unfold terminating_closure_scheme_const_def<span class="delimiter">)</span>
<span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule_tac x<span class="delimiter">=</span><span class="string">&quot;f<span class="hidden">&#8681;</span><sub>c</sub>&quot;</span> <span class="keyword2">in</span> exI<span class="delimiter">)</span>
<span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>rule_tac x<span class="delimiter">=</span><span class="string">&quot;g<span class="hidden">&#8681;</span><sub>c</sub>&quot;</span> <span class="keyword2">in</span> exI<span class="delimiter">)</span>
<span class="keyword1">by</span> simp

<span class="keyword1">subsection</span> <span class="verbatim">{* Evaluation of the Evolve algorithm. *}</span>

<span class="keyword1">text</span> <span class="verbatim">{* We define the fitness function, the termination criterion,
  and other GP related parameters.
*}</span>

<span class="keyword1">ML</span> <span class="verbatim">{*
  fun fitness ctxt functions =
    let val in_out = [(@{term &quot;0::nat&quot;}, @{term &quot;True&quot;} ,@{term &quot;False&quot;}),
                      (@{term &quot;1::nat&quot;}, @{term &quot;False&quot;} ,@{term &quot;True&quot;}),
                      (@{term &quot;2::nat&quot;}, @{term &quot;True&quot;} ,@{term &quot;False&quot;}),
                      (@{term &quot;3::nat&quot;}, @{term &quot;False&quot;} ,@{term &quot;True&quot;}),
                      (@{term &quot;4::nat&quot;}, @{term &quot;True&quot;} ,@{term &quot;False&quot;})]
        val c = @{term &quot;6::nat&quot;}
        val v = @{term &quot;False&quot;}
        val f = hd functions
        val g = (hd o tl) functions
        val error = 
          in_out |&gt; map (fn (x,r1,r2) =&gt; 
                          (Value.value ctxt (f $ c $ c $ v $ v $ x), Value.value ctxt (g $ c $ c $ v $ v $ x), r1, r2))
                 |&gt; map (fn (i1, i2, r1, r2) =&gt; (if i1 = r1 then 0 else 1) + 
                                                (if i2 = r2 then 0 else 1))
    in (0, error) |&gt; Library.foldl (op +)
                  |&gt; Rat.rat_of_int end
  fun finish ({fit, ...} : GP.individual) = case fit of
                                              SOME fit =&gt; Rat.eq (Rat.zero, fit)
                                            | NONE =&gt; false
  fun test ctxt consts =
      consts |&gt; fitness ctxt
             |&gt; pair Rat.zero
             |&gt; Rat.eq
  val term_size = 25
  val max_term_size_dest = 30
  val max_term_size_const = 30
  val population_size = 500
  val generations = 500
  val bests = 10
  val mut_prob = 0.05
  val scheme_dest = @{thm &quot;scheme_dest_def&quot;}
  val scheme_const = @{thm &quot;scheme_const_def&quot;}
  val functions_dest = [@{term &quot;f<span class="hidden">&#8681;</span><sub>d</sub>&quot;}, @{term &quot;g<span class="hidden">&#8681;</span><sub>d</sub>&quot;}]
  val functions_const = [@{term &quot;f<span class="hidden">&#8681;</span><sub>c</sub>&quot;}, @{term &quot;g<span class="hidden">&#8681;</span><sub>c</sub>&quot;}]
  val experiments = 20
  val recursive_calls = 1
  val bad_fitness = Rat.rat_of_int 10
*}</span>

<span class="keyword1">text</span> <span class="verbatim">{* We finally call the GP algorithm. *}</span>

<span class="keyword1">local_setup</span> <span class="verbatim">{*
 fn lthy =&gt;
    let val experiment = GP.evolve true false true &quot;EvenOddDest.log&quot; scheme_dest functions_dest recursive_calls bad_fitness lthy fitness finish
                                   term_size max_term_size_dest population_size generations bests mut_prob
        val _ = MySQL.new_experiment &quot;EvenOddDest&quot; generations term_size population_size experiment
    in lthy end
*}</span>

<span class="keyword1">local_setup</span> <span class="verbatim">{*
 fn lthy =&gt;
    let val experiment = GP.evolve true false false &quot;EvenOddConsts.log&quot; scheme_const functions_const recursive_calls bad_fitness lthy fitness finish
                                   term_size max_term_size_const population_size generations bests mut_prob
        val _ = MySQL.new_experiment &quot;EvenOddConsts&quot; generations term_size population_size experiment
    in lthy end
*}</span>

<span class="keyword2">end</span></pre>

</div>
</body>
</html>
