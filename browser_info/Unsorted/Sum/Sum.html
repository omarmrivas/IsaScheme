<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Sum (Isabelle2015: May 2015)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Sum</h1>

<span class="command">theory</span> <span class="name">Sum</span><br/>
<span class="keyword">imports</span> <a href="IsaLibs.html"><span class="name">IsaLibs</span></a><br/>

</div>
<div class="source">
<pre><span class="keyword1">theory</span> Sum
<span class="keyword2">imports</span> <span class="string">&quot;IsaLibs/IsaLibs&quot;</span>
<span class="keyword2">begin</span>

<span class="keyword1">section</span> <span class="verbatim">{* Summation *}</span>

<span class="keyword1">text</span> <span class="verbatim">{* This theory file shows how to find a function that adds the elements of a list of natural 
numbers in Isabelle/HOL. *}</span>

<span class="keyword1">subsection</span> <span class="verbatim">{* Destructor style functional scheme *}</span>

<span class="keyword1">text</span> <span class="verbatim">{* We first define the functional space of a destructor style functional scheme. *}</span>

<span class="keyword1">definition</span> scheme_dest <span class="keyword2">where</span>
<span class="string">&quot;scheme_dest N &equiv; &exist;(f::int list=&gt;int). &forall;(xs::int list).
  f xs = N xs
           (&lambda;x (y::int) z. if x then y else z)
           (op = :: int list=&gt;int list=&gt;bool)
           ([] :: int list)
           (op + :: int=&gt;int=&gt;int)
           (0 :: int)
           (&lambda;xs. if xs = [] then (0::int) else hd xs)
           (tl :: int list=&gt;int list)
           f&quot;</span>

<span class="keyword1">text</span> <span class="verbatim">{* Now we get the terminating closure of the destructor style functional scheme. *}</span>

<span class="keyword1">definition</span> terminating_closure_scheme_dest <span class="keyword2">where</span>
<span class="string">&quot;terminating_closure_scheme_dest N &equiv; &exist;f. &forall;(xs::int list) (c<span class="hidden">&#8681;</span><sub>f</sub>::nat) v<span class="hidden">&#8681;</span><sub>f</sub>.
  ((f N 0 v<span class="hidden">&#8681;</span><sub>f</sub> xs = v<span class="hidden">&#8681;</span><sub>f</sub>) &and;
   (f N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> xs::int) = N xs
           (&lambda;x (y::int) z. if x then y else z)
           (op = :: int list=&gt;int list=&gt;bool)
           ([] :: int list)
           (op + :: int=&gt;int=&gt;int)
           (0 :: int)
           (&lambda;xs. if xs = [] then (0::int) else hd xs)
           (tl :: int list=&gt;int list)
           (f N c<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>f</sub>))&quot;</span>

<span class="keyword1">text</span> <span class="verbatim">{* All individuals generated by @{term &quot;terminating_closure_scheme_dest&quot;}
  are terminating, regardless the value of @{term &quot;N&quot;}. The proof will need 
  the witness @{term &quot;f<span class="hidden">&#8681;</span><sub>d</sub>&quot;} which we define below. *}</span>

<span class="keyword1">fun</span> f<span class="hidden">&#8681;</span><sub>d</sub> <span class="keyword2">where</span>
<span class="string">&quot;f<span class="hidden">&#8681;</span><sub>d</sub> N (0::nat) v<span class="hidden">&#8681;</span><sub>f</sub> (xs::int list) = (v<span class="hidden">&#8681;</span><sub>f</sub>::int)&quot;</span> <span class="delimiter">|</span>
<span class="string">&quot;f<span class="hidden">&#8681;</span><sub>d</sub> N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> xs = N xs
           (&lambda;x (y::int) z. if x then y else z)
           (op = :: int list=&gt;int list=&gt;bool)
           ([] :: int list)
           (op + :: int=&gt;int=&gt;int)
           (0 :: int)
           (&lambda;xs. if xs = [] then (0::int) else hd xs)
           (tl :: int list=&gt;int list)
           (f<span class="hidden">&#8681;</span><sub>d</sub> N c<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>f</sub>)&quot;</span>

<span class="keyword1">text</span> <span class="verbatim">{* Proof. *}</span>

<span class="keyword1">theorem</span> <span class="string">&quot;terminating_closure_scheme_dest N&quot;</span>
<span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>unfold terminating_closure_scheme_dest_def<span class="delimiter">)</span>
<span class="keyword1">by</span> <span class="delimiter">(</span>rule_tac x<span class="delimiter">=</span><span class="string">&quot;f<span class="hidden">&#8681;</span><sub>d</sub>&quot;</span> <span class="keyword2">in</span> exI<span class="delimiter">,</span> simp<span class="delimiter">)</span>

<span class="keyword1">subsection</span> <span class="verbatim">{* Constructor style functional scheme *}</span>

<span class="keyword1">text</span> <span class="verbatim">{* Now we define the functional space of a constructor style functional scheme. *}</span>

<span class="keyword1">definition</span> scheme_const <span class="keyword2">where</span>
<span class="string">&quot;scheme_const N &equiv; &exist;(f::int list=&gt;int). &forall;(xs::int list) (x::int).
  (f [] = (0::int)) &and;
  (f (x#xs) = N x
                xs
                (op + :: int=&gt;int=&gt;int)
                f)&quot;</span>

<span class="keyword1">text</span> <span class="verbatim">{* Now we get the terminating closure of the constructor style functional scheme. *}</span>

<span class="keyword1">definition</span> terminating_closure_scheme_const <span class="keyword2">where</span>
<span class="string">&quot;terminating_closure_scheme_const N &equiv; &exist;f. &forall;(xs::int list) (x::int) c<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>f</sub>.
  (f N 0 v<span class="hidden">&#8681;</span><sub>f</sub> xs = v<span class="hidden">&#8681;</span><sub>f</sub>) &and;
  (f N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> [] = (0::int)) &and;
  (f N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> (x#xs) = N x
                xs
                (op + :: int=&gt;int=&gt;int)
                (f N c<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>f</sub>))&quot;</span>

<span class="keyword1">text</span> <span class="verbatim">{* All individuals generated by @{term &quot;terminating_closure_scheme_const&quot;}
  are terminating, regardless the value of @{term &quot;N&quot;}. The proof will need 
  the witness @{term &quot;f<span class="hidden">&#8681;</span><sub>c</sub>&quot;} which we define below. *}</span>

<span class="keyword1">fun</span> f<span class="hidden">&#8681;</span><sub>c</sub> <span class="keyword2">where</span>
<span class="string">&quot;f<span class="hidden">&#8681;</span><sub>c</sub> N 0 v<span class="hidden">&#8681;</span><sub>f</sub> (xs::int list) = v<span class="hidden">&#8681;</span><sub>f</sub>&quot;</span><span class="delimiter">|</span>
<span class="string">&quot;f<span class="hidden">&#8681;</span><sub>c</sub> N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> [] = (0::int)&quot;</span><span class="delimiter">|</span>
<span class="string">&quot;f<span class="hidden">&#8681;</span><sub>c</sub> N (Suc c<span class="hidden">&#8681;</span><sub>f</sub>) v<span class="hidden">&#8681;</span><sub>f</sub> (x#xs) = N x
                xs
                (op + :: int=&gt;int=&gt;int)
                (f<span class="hidden">&#8681;</span><sub>c</sub> N c<span class="hidden">&#8681;</span><sub>f</sub> v<span class="hidden">&#8681;</span><sub>f</sub>)&quot;</span>

<span class="keyword1">text</span> <span class="verbatim">{* Proof. *}</span>

<span class="keyword1">theorem</span> <span class="string">&quot;terminating_closure_scheme_const N&quot;</span>
<span class="keyword1"><span class="improper">apply</span></span> <span class="delimiter">(</span>unfold terminating_closure_scheme_const_def<span class="delimiter">)</span>
<span class="keyword1">by</span> <span class="delimiter">(</span>rule_tac x<span class="delimiter">=</span><span class="string">&quot;f<span class="hidden">&#8681;</span><sub>c</sub>&quot;</span> <span class="keyword2">in</span> exI<span class="delimiter">,</span> simp<span class="delimiter">)</span>

<span class="keyword1">subsection</span> <span class="verbatim">{* Evaluation of the Evolve algorithm. *}</span>

<span class="keyword1">text</span> <span class="verbatim">{* We define the fitness function, the termination criterion,
  and other GP related parameters.
*}</span>

<span class="keyword1">ML</span> <span class="verbatim">{*
  fun fitness ctxt functions =
    let val in_out = [(@{term &quot;[9,2] :: int list&quot;},11),
                      (@{term &quot;[1]:: int list&quot;},1),
                      (@{term &quot;[1,2]:: int list&quot;},3),
                      (@{term &quot;[1,2,3]:: int list&quot;},6),
                      (@{term &quot;[1,2,3,4]:: int list&quot;},10),
                      (@{term &quot;[1,2,3,4,5]:: int list&quot;},15),
                      (@{term &quot;[1,2,3,4,5,6]:: int list&quot;},21),
                      (@{term &quot;[1,2,3,4,5,6,7]:: int list&quot;},28),
                      (@{term &quot;[1,2,3,4,5,6,7,8]:: int list&quot;},36),
                      (@{term &quot;[1,2,3,4,5,6,7,8,9]:: int list&quot;},45)]
        val rec_counter = @{term &quot;10::nat&quot;}
        val vf = @{term &quot;0 :: int&quot;}
        val f = hd functions
        val error = 
          in_out |&gt; map (fn (xs,r) =&gt; (Value.value ctxt (f $ rec_counter $ vf $ xs), r))
                 |&gt; map (fn (i, r) =&gt; let val err = Utils.int_of_numeral i - r
                                      in err * err end)
    in (0, error) |&gt; Library.foldl (op +)
                  |&gt; Rat.rat_of_int end
  fun finish ({fit, ...} : GP.individual) = case fit of
                                              SOME fit =&gt; Rat.eq (Rat.zero, fit)
                                            | NONE =&gt; false
  fun test ctxt consts =
      consts |&gt; fitness ctxt
             |&gt; pair Rat.zero
             |&gt; Rat.eq
  val term_size = 25
  val max_term_size_dest = 30
  val max_term_size_const = 30
  val population_size = 500
  val generations = 500
  val bests = 10
  val mut_prob = 0.05
  val scheme_dest = @{thm &quot;scheme_dest_def&quot;}
  val scheme_const = @{thm &quot;scheme_const_def&quot;}
  val functions_dest = [@{term &quot;f<span class="hidden">&#8681;</span><sub>d</sub>&quot;}]
  val functions_const = [@{term &quot;f<span class="hidden">&#8681;</span><sub>c</sub>&quot;}]
  val experiments = 20
  val recursive_calls = 1
  val bad_fitness = Rat.rat_of_int 10
*}</span>

<span class="keyword1">text</span> <span class="verbatim">{* We finally call the Evolve algorithm. *}</span>

<span class="keyword1">local_setup</span> <span class="verbatim">{*
 fn lthy =&gt;
    let val experiment = GP.evolve true false false &quot;SumConsts.log&quot; scheme_const functions_const recursive_calls bad_fitness lthy fitness finish
                                   term_size max_term_size_const population_size generations bests mut_prob
        val _ = MySQL.new_experiment &quot;SumConsts&quot; generations term_size population_size experiment
    in lthy end
*}</span>

<span class="keyword1">local_setup</span> <span class="verbatim">{*
 fn lthy =&gt;
    let val experiment = GP.evolve true false false &quot;SumDest.log&quot; scheme_dest functions_dest recursive_calls bad_fitness lthy fitness finish
                                   term_size max_term_size_dest population_size generations bests mut_prob
        val _ = MySQL.new_experiment &quot;SumDest&quot; generations term_size population_size experiment
    in lthy end
*}</span>

<span class="keyword2">end</span></pre>

</div>
</body>
</html>
