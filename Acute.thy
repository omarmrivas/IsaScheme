theory Acute
imports "IsaLibs/IsaLibs"
begin

section {* Acute *}

declare [[max_time_in_fitness = 1200]]

text {* This theory file shows how to find a function that performs the presumptive diagnosis of two 
diseases of the urinary system in Isabelle/HOL. The data was created by a medical expert as a data set to test 
a expert system.

The database was taken from: https://archive.ics.uci.edu/ml/machine-learning-databases/abalone/
 *}

subsection {* Destructor style functional scheme *}

text {* We first define the functional space of a destructor style functional scheme. *}

definition scheme_dest where
"scheme_dest N \<equiv> \<exists>(f::real\<Rightarrow>bool\<Rightarrow>bool\<Rightarrow>bool\<Rightarrow>bool\<Rightarrow>bool\<Rightarrow>bool).
                 \<forall>(v1::real) (v2::bool) (v3::bool) (v4::bool)
                  (v5::bool) (v6::bool).
  f v1 v2 v3 v4 v5 v6 = N v1 v2 v3 v4 v5 v6
           (\<lambda>x (y::real) (z::real) w. (case x < y of True \<Rightarrow> z | _ \<Rightarrow> w))
           (\<lambda>x (y::real). x + y)
           (\<lambda>x (y::real). x - y)
           (\<lambda>x (y::real). x * y)
           (\<lambda>x (y::real). x / y)
           (1::real)
           (10::real)
           (\<lambda>x. \<not> x)
           (\<lambda>x y. x \<and> y)
           (\<lambda>x y. x \<or> y)
           f"

text {* Now we get the terminating closure of the destructor style functional scheme. *}

definition terminating_closure_scheme_dest where
"terminating_closure_scheme_dest N \<equiv> \<exists>f.
                  \<forall>(v1::real) (v2::bool) (v3::bool) (v4::bool)
                  (v5::bool) (v6::bool) (c\<^sub>f::nat) (v\<^sub>f::bool).
  ((f N 0 v\<^sub>f v1 v2 v3 v4 v5 v6 = v\<^sub>f) \<and>
   (f N (Suc c\<^sub>f) v\<^sub>f v1 v2 v3 v4 v5 v6 = N v1 v2 v3 v4 v5 v6
           (\<lambda>x (y::real) (z::real) w. (case x < y of True \<Rightarrow> z | _ \<Rightarrow> w))
           (\<lambda>x (y::real). x + y)
           (\<lambda>x (y::real). x - y)
           (\<lambda>x (y::real). x * y)
           (\<lambda>x (y::real). x / y)
           (1::real)
           (10::real)
           (\<lambda>x. \<not> x)
           (\<lambda>x y. x \<and> y)
           (\<lambda>x y. x \<or> y)
           (f N c\<^sub>f v\<^sub>f)))"

text {* All individuals generated by @{term "terminating_closure_scheme_dest"}
  are terminating, regardless the value of @{term "N"}. The proof will need 
  the witness @{term "f\<^sub>d"} which we define below. *}

fun f\<^sub>d where
"f\<^sub>d N (0::nat) v\<^sub>f (v1::real) (v2::bool) (v3::bool) (v4::bool) (v5::bool) (v6::bool) = (v\<^sub>f::bool)" |
"f\<^sub>d N (Suc c\<^sub>f) v\<^sub>f (v1::real) (v2::bool) (v3::bool) (v4::bool) (v5::bool) (v6::bool) = N v1 v2 v3 v4 v5 v6
           (\<lambda>x (y::real) (z::real) w. (case x < y of True \<Rightarrow> z | _ \<Rightarrow> w))
           (\<lambda>x (y::real). x + y)
           (\<lambda>x (y::real). x - y)
           (\<lambda>x (y::real). x * y)
           (\<lambda>x (y::real). x / y)
           (1::real)
           (10::real)
           (\<lambda>x. \<not> x)
           (\<lambda>x y. x \<and> y)
           (\<lambda>x y. x \<or> y)
           (f\<^sub>d N c\<^sub>f v\<^sub>f)"

text {* Proof. *}

theorem "terminating_closure_scheme_dest N"
apply (unfold terminating_closure_scheme_dest_def)
by (rule_tac x="f\<^sub>d" in exI, simp)

subsection {* Constructor style functional scheme *}

text {* Now we define the functional space of a constructor style functional scheme. *}

definition scheme_const where
"scheme_const N \<equiv> \<exists>(f::real\<Rightarrow>bool\<Rightarrow>bool\<Rightarrow>bool\<Rightarrow>bool\<Rightarrow>bool\<Rightarrow>bool).
                 \<forall>(v1::real) (v2::bool) (v3::bool) (v4::bool)
                  (v5::bool) (v6::bool).
  (f v1 v2 v3 v4 v5 v6 = N v1 v2 v3 v4 v5 v6
           (\<lambda>x (y::real) (z::real) w. (case x < y of True \<Rightarrow> z | _ \<Rightarrow> w))
           (\<lambda>x (y::real). x + y)
           (\<lambda>x (y::real). x - y)
           (\<lambda>x (y::real). x * y)
           (\<lambda>x (y::real). x / y)
           (1::real)
           (10::real)
           (\<lambda>x. \<not> x)
           (\<lambda>x y. x \<and> y)
           (\<lambda>x y. x \<or> y)
           f)"

text {* Now we get the terminating closure of the constructor style functional scheme. *}

definition terminating_closure_scheme_const where
"terminating_closure_scheme_const N \<equiv> \<exists>f.
                 \<forall>(v1::real) (v2::bool) (v3::bool) (v4::bool)
                  (v5::bool) (v6::bool) c\<^sub>f (v\<^sub>f::bool).
  (f N 0 v\<^sub>f v1 v2 v3 v4 v5 v6 = v\<^sub>f) \<and>
  (f N (Suc c\<^sub>f) v\<^sub>f v1 v2 v3 v4 v5 v6 = (N v1 v2 v3 v4 v5 v6
           (\<lambda>x (y::real) (z::real) w. (case x < y of True \<Rightarrow> z | _ \<Rightarrow> w))
           (\<lambda>x (y::real). x + y)
           (\<lambda>x (y::real). x - y)
           (\<lambda>x (y::real). x * y)
           (\<lambda>x (y::real). x / y)
           (1::real)
           (10::real)
           (\<lambda>x. \<not> x)
           (\<lambda>x y. x \<and> y)
           (\<lambda>x y. x \<or> y)
                    (f N c\<^sub>f v\<^sub>f)))"

text {* All individuals generated by @{term "terminating_closure_scheme_const"}
  are terminating, regardless the value of @{term "N"}. The proof will need 
  the witness @{term "f\<^sub>c"} which we define below. *}

fun f\<^sub>c where
"f\<^sub>c N 0 v\<^sub>f (v1::real) (v2::bool) (v3::bool) (v4::bool) (v5::bool) (v6::bool) = (v\<^sub>f::bool)" |
"f\<^sub>c N (Suc c\<^sub>f) v\<^sub>f (v1::real) (v2::bool) (v3::bool) (v4::bool) (v5::bool) (v6::bool) = (N v1 v2 v3 v4 v5 v6
           (\<lambda>x (y::real) (z::real) w. (case x < y of True \<Rightarrow> z | _ \<Rightarrow> w))
           (\<lambda>x (y::real). x + y)
           (\<lambda>x (y::real). x - y)
           (\<lambda>x (y::real). x * y)
           (\<lambda>x (y::real). x / y)
           (1::real)
           (10::real)
           (\<lambda>x. \<not> x)
           (\<lambda>x y. x \<and> y)
           (\<lambda>x y. x \<or> y)
                    (f\<^sub>c N c\<^sub>f v\<^sub>f))"

text {* Proof. *}

theorem "terminating_closure_scheme_const N"
apply (unfold terminating_closure_scheme_const_def)
by (rule_tac x="f\<^sub>c" in exI, simp)

subsection {* Evaluation of the Evolve algorithm. *}

text {* We define the fitness function, the termination criterion,
  and other GP related parameters.
*}

ML {*
  fun my_trim str =
    if can (unsuffix " ") str
    then (if can (unprefix " ") str
         then my_trim (unprefix " " (unsuffix " " str))
         else my_trim (unsuffix " " str))
    else (if can (unprefix " ") str
         then my_trim (unprefix " " str)
         else str)
  fun real_str_to_rat str =
    str |> space_explode "/"
        |> map (Rat.rat_of_int o Utils.int_of_string o my_trim)
        |> (fn l => let val h = hd l
                    in
                    Library.foldl (fn (r,i) => i |> Rat.inv
                                                 |> Rat.mult r
                                                 handle Rat.DIVZERO => (tracing str; r)) (Rat.mult h h, l)
                    end)
  val ctxt = @{context}
  val data = ML_Database.load_file ctxt [ML_Database.Real,
                                               ML_Database.String,
                                               ML_Database.String,
                                               ML_Database.String,
                                               ML_Database.String,
                                               ML_Database.String,
                                               ML_Database.String]
                                               "/Users/omarmrivas/Programs/IsaLibs/experiments/machine_learning/acute-inflammations-urinary.arff"
              |> map (fn row => map (fn h => if h = Syntax.read_term ctxt "''no'' :: string"
                                              then @{term "False"}
                                              else if h = Syntax.read_term ctxt "''yes'' :: string"
                                              then @{term "True"}
                                              else h) row)
              |> map split_last

  fun fitness ctxt functions =
    let val in_out = data
        val rec_counter = @{term "10::nat"}
        val vf = @{term "False"}
        val f = hd functions
        val error = 
          in_out |> Par_List.map (fn (xs,r) => list_comb (f $ rec_counter $ vf, xs)
                                        |> (fn x => if Value.value ctxt x = r
                                                    then Rat.zero
                                                    else Rat.one))
    in (Rat.zero, error) |> Library.foldl (fn (x,y) => Rat.add x y) end
  fun finish ({fit, ...} : GP.individual) = case fit of
                                              SOME fit => Rat.le fit (Rat.rat_of_int 0)
                                            | NONE => false
  val term_size = 30
  val max_term_size_dest = 40
  val max_term_size_const = 40
  val population_size = 500
  val generations = 500
  val bests = 10
  val mut_prob = 0.05
  val scheme_dest = @{thm "scheme_dest_def"}
  val scheme_const = @{thm "scheme_const_def"}
  val functions_dest = [@{term "f\<^sub>d"}]
  val functions_const = [@{term "f\<^sub>c"}]
  val experiments = 20
  val recursive_calls = 1
  val bad_fitness = Rat.rat_of_int 200
*}

text {* We finally call the Evolve algorithm. *}

local_setup {*
 fn lthy =>
    let val experiment = GP.evolve false true false "AcuteConsts.log" scheme_const functions_const recursive_calls bad_fitness lthy fitness finish
                                   term_size max_term_size_const population_size generations bests mut_prob
        val _ = MySQL.new_experiment "AcuteConsts" generations term_size population_size experiment
    in lthy end
*}

local_setup {*
 fn lthy =>
    let val experiment = GP.evolve false false false "AcuteDest.log" scheme_dest functions_dest recursive_calls bad_fitness lthy fitness finish
                                   term_size max_term_size_dest population_size generations bests mut_prob
        val _ = MySQL.new_experiment "AcuteDest" generations term_size population_size experiment
    in lthy end
*}

end