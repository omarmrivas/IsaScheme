theory Ackermann
imports "IsaLibs/IsaLibs"
begin

declare [[max_time_in_fitness = 20]]

section {* Ackermann *}

text {* Total computable functions, such as the Ackermann function, are naturally expressed 
 using our technique. This theory file shows how to do it using Isabelle/HOL. *}

subsection {* Destructor style functional scheme *}

text {* We first define the functional space of a destructor style functional scheme. *}

definition scheme_dest where
"scheme_dest M \<equiv> \<exists>(f::nat\<Rightarrow>nat\<Rightarrow>nat). \<forall>(x::nat) (y::nat).
  (f x y = M x y (0::nat) Suc (\<lambda>x. x - (1::nat))
             (\<lambda>x y z. if x then (y::nat) else z)
             (op = :: nat\<Rightarrow>nat\<Rightarrow>bool) (f (x-1)) (f x))"

text {* Now we get the terminating closure of the destructor style functional scheme. *}

definition terminating_closure_scheme_dest where
"terminating_closure_scheme_dest M \<equiv> \<exists>f. \<forall>(x::nat) (y::nat) c\<^sub>f (v\<^sub>f::nat).
  ((f M 0 v\<^sub>f x y = v\<^sub>f) \<and>
   (f M (Suc c\<^sub>f) v\<^sub>f x y = M x y (0::nat) Suc
                                 (\<lambda>x. x - (1::nat))
                                 (\<lambda>x y z. if x then (y::nat) else z)
                                 (op = :: nat\<Rightarrow>nat\<Rightarrow>bool)
                                 (f M c\<^sub>f v\<^sub>f (x-1)) (f M c\<^sub>f v\<^sub>f x)))"

text {* All individuals generated by @{term "terminating_closure_scheme_dest"}
  are terminating, regardless the value of @{term "M"}. The proof will need
  the witness @{term "f\<^sub>d"} which we define below. *}

fun f\<^sub>d where
"f\<^sub>d M 0 v\<^sub>f (x::nat) y = (v\<^sub>f::nat)"|
"f\<^sub>d M (Suc c\<^sub>f) v\<^sub>f x (y::nat) = M x y (0::nat) Suc
                                 (\<lambda>x. x - (1::nat))
                                 (\<lambda>x y z. if x then (y::nat) else z)
                                 (op = :: nat\<Rightarrow>nat\<Rightarrow>bool)
                                 (f\<^sub>d M c\<^sub>f v\<^sub>f (x-1))
                                 (f\<^sub>d M c\<^sub>f v\<^sub>f x)"

text {* Proof. *}

theorem "terminating_closure_scheme_dest M"
apply (unfold terminating_closure_scheme_dest_def)
apply (rule_tac x="f\<^sub>d" in exI)
by simp

subsection {* Constructor style functional scheme *}

text {* We define the functional space of a constructor style functional scheme. *}

definition scheme_const where
"scheme_const M N \<equiv> \<exists>(f::nat\<Rightarrow>nat\<Rightarrow>nat). \<forall>(x::nat) (y::nat).
  ((f 0 y = Suc y) \<and>
   (f (Suc x) 0 = M x Suc (0::nat) (f x)) \<and>
   (f (Suc x) (Suc y) = N x y Suc (0::nat) (f x) (f (Suc x))))"

text {* Now we get the terminating closure of the constructor style functional scheme. *}

definition terminating_closure_scheme_const where
"terminating_closure_scheme_const M N \<equiv> \<exists>f. \<forall>(x::nat) (y::nat) c\<^sub>f v\<^sub>f.
  ((f M N 0 v\<^sub>f x y = v\<^sub>f) \<and>
   (f M N (Suc c\<^sub>f) v\<^sub>f 0 y = Suc y) \<and>
   (f M N (Suc c\<^sub>f) v\<^sub>f (Suc x) 0 = M x Suc (0::nat)
                                 (f M N c\<^sub>f v\<^sub>f x)) \<and>
   (f M N (Suc c\<^sub>f) v\<^sub>f (Suc x) (Suc y) = N x y Suc (0::nat)
                                 (f M N c\<^sub>f v\<^sub>f x)
                                 (f M N c\<^sub>f v\<^sub>f (Suc x))))"

text {* All individuals generated by @{term "terminating_closure_scheme_const"}
  are terminating, regardless the value of @{term "M"} and @{term "N"}. *}

text {* All individuals generated by @{term "terminating_closure_scheme_const"}
  are terminating, regardless the values of @{term "M"} and @{term "N"}. The proof will need 
  the witness @{term "f\<^sub>c"} which we define below. *}

fun f\<^sub>c where
"f\<^sub>c M N 0 v\<^sub>f x y = v\<^sub>f"|
"f\<^sub>c M N (Suc c\<^sub>f) v\<^sub>f 0 y = Suc y"|
"f\<^sub>c M N (Suc c\<^sub>f) v\<^sub>f (Suc x) 0 = M x Suc (0::nat)
                                 (f\<^sub>c M N c\<^sub>f v\<^sub>f x)"|
"f\<^sub>c M N (Suc c\<^sub>f) v\<^sub>f (Suc x) (Suc y) = N x y Suc (0::nat)
                                 (f\<^sub>c M N c\<^sub>f v\<^sub>f x)
                                 (f\<^sub>c M N c\<^sub>f v\<^sub>f (Suc x))"

text {* Proof. *}

theorem "terminating_closure_scheme_const M N"
apply (unfold terminating_closure_scheme_const_def)
apply (rule_tac x="f\<^sub>c" in exI)
by simp

subsection {* Evaluation of the Evolve algorithm. *}

text {* We define the fitness function, the termination criterion,
  and other GP related parameters.
*}

ML {*
  fun fitness ctxt functions =
    let val in_out = [(@{term "0::nat"},@{term "0::nat"},1), (@{term "1::nat"},@{term "0::nat"},2),
                      (@{term "0::nat"},@{term "1::nat"},2), (@{term "1::nat"},@{term "1::nat"},3),
                      (@{term "1::nat"},@{term "2::nat"},4), (@{term "2::nat"},@{term "1::nat"},5),
                      (@{term "2::nat"},@{term "2::nat"},7), (@{term "Suc (Suc 0)"},@{term "0::nat"},3),
                      (@{term "0::nat"},@{term "2::nat"},3)]
        val f = hd functions
        val c = @{term "100::nat"}
        val v = @{term "100 :: nat"}
        val to_int = @{term "(numeral o num_of_nat) :: nat\<Rightarrow>int"}
        val error =
          in_out |> map (fn (x,y,r) => (Value.value ctxt (to_int $ (f $ c $ v $ x $ y)), r))
                 |> map (fn (i, r) => let val err = Utils.int_of_numeral i - r
                                      in err * err end)
    in (0, error) |> Library.foldl (op +)
                  |> Rat.rat_of_int end
  fun finish ({fit, ...} : GP.individual) = case fit of
                                              SOME fit => Rat.eq (Rat.zero, fit)
                                            | NONE => false
  fun test ctxt consts =
      consts |> fitness ctxt
             |> pair Rat.zero
             |> Rat.eq
  val term_size = 25
  val max_term_size_dest = 30
  val max_term_size_const = 30
  val population_size = 500
  val generations = 500
  val bests = 10
  val mut_prob = 0.05
  val scheme_dest = @{thm "scheme_dest_def"}
  val scheme_const = @{thm "scheme_const_def"}
  val functions_dest = [@{term "f\<^sub>d"}]
  val functions_const = [@{term "f\<^sub>c"}]
  val experiments = 20
  val recursive_calls = 2
  val bad_fitness = Rat.rat_of_int 1000
*}

text {* We finally call the GP algorithm. *}

local_setup {*
 fn lthy =>
    let val experiment = GP.evolve true false true "AckermannDest.log" scheme_dest functions_dest recursive_calls bad_fitness lthy fitness finish
                                   term_size max_term_size_dest population_size generations bests mut_prob
        val _ = MySQL.new_experiment "AckermannDest" generations term_size population_size experiment
    in lthy end
*}

local_setup {*
 fn lthy =>
    let val experiment = GP.evolve true false false "AckermannConsts.log" scheme_const functions_const recursive_calls bad_fitness lthy fitness finish
                                   term_size max_term_size_const population_size generations bests mut_prob
        val _ = MySQL.new_experiment "AckermannConsts" generations term_size population_size experiment
    in lthy end
*}

end